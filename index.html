<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MeteoRide</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='sky' x1='0%25' y1='0%25' x2='0%25' y2='100%25'><stop offset='0%25' stop-color='%2387CEEB'/><stop offset='100%25' stop-color='%23E0F6FF'/></linearGradient><linearGradient id='bike' x1='0%25' y1='0%25' x2='100%25' y2='0%25'><stop offset='0%25' stop-color='%232563eb'/><stop offset='100%25' stop-color='%231d4ed8'/></linearGradient></defs><rect width='100' height='100' fill='url(%23sky)' rx='20'/><circle cx='25' cy='70' r='12' fill='%23374151' stroke='%23111827' stroke-width='2'/><circle cx='75' cy='70' r='12' fill='%23374151' stroke='%23111827' stroke-width='2'/><path d='M25 70 L40 50 L60 50 L75 70' fill='none' stroke='url(%23bike)' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/><path d='M40 50 L45 35 L55 35' fill='none' stroke='url(%23bike)' stroke-width='3' stroke-linecap='round'/><path d='M50 35 L50 45' fill='none' stroke='url(%23bike)' stroke-width='2' stroke-linecap='round'/><circle cx='30' cy='25' r='8' fill='%23FCD34D' stroke='%23F59E0B' stroke-width='1.5'/><path d='M22 25 L30 25 L38 25 M30 17 L30 25 L30 33' stroke='%23F59E0B' stroke-width='1.5' stroke-linecap='round'/><path d='M65 30 C68 30 70 32 70 35 C70 38 68 40 65 40 C62 40 60 38 60 35 C60 32 62 30 65 30' fill='%23E5E7EB' stroke='%23D1D5DB' stroke-width='1'/><path d='M80 20 C83 20 85 22 85 25 C85 28 83 30 80 30 C77 30 75 28 75 25 C75 22 77 20 80 20' fill='%23F3F4F6' stroke='%23D1D5DB' stroke-width='1'/></svg>"/>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/weather-icons/2.0.12/css/weather-icons.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/weather-icons/2.0.12/css/weather-icons-wind.min.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-compass@1.5.6/dist/leaflet-compass.min.css" />

<!-- iOS PWA meta -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="mobile-web-app-capable" content="yes" /> <!-- NEW: recommended meta to silence deprecation warning -->
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
</head>
<body>
<header>
<!-- traducible: t√≠tulo de la app -->
<h1 data-i18n="title">üö¥ MeteoRide</h1>
<nav>
<button id="toggleConfig" title="Configuraci√≥n">
  <span class="config-text" data-i18n="toggle_config">Configuraci√≥n</span>
  <span class="config-ico" aria-hidden="true">‚öôÔ∏è</span>
</button>
<button id="toggleHelp" data-i18n="toggle_help" title="Ayuda">
  <span class="help-text">Ayuda</span> ‚ùì
</button>
<button id="toggleDebug" data-i18n="toggle_debug" style="display: none;">Depuraci√≥n üêû</button>
</nav>
</header>

<aside id="configMenu" style="display: none;">
  <div class="config-panel">
    <div class="config-row">
    </div>

    <!-- NEW: Notice verbosity option -->
    <div class="config-row">
      <label class="inline">
        <input type="checkbox" id="noticeAll" checked />
        <span data-i18n="notices_noncritical_label">Mostrar avisos no cr√≠ticos</span>
      </label>
    </div>

    <h4 style="font-size: 14px; margin: 8px 0; text-decoration: underline; color: #203050;" data-i18n="api_key_init">API Key</h4>
    <div class="config-row">
      <label for="apiKey" data-i18n="api_key_label">MeteoBlue:</label>
      <input type="text" id="apiKey" data-i18n-placeholder="api_key_placeholder" placeholder="Introduce la API Key MeteoBlue" />
      <button type="button" id="checkApiKey" data-i18n="check_key">Check</button>
    </div>
    <div id="apiKeyStatus" class="key-status" aria-live="polite"></div>

    <div class="config-row">
      <label for="apiKeyOW" data-i18n="api_key_label_ow">OpenWeather:</label>
      <input type="text" id="apiKeyOW" data-i18n-placeholder="api_key_placeholder" placeholder="Introduce la API Key OpenWeather" />
      <button type="button" id="checkApiKeyOW" data-i18n="check_key">Check</button>
    </div>
    <div id="apiKeyStatusOW" class="key-status" aria-live="polite"></div>

    <h4 style="font-size: 14px; margin: 8px 0; text-decoration: underline; color: #203050;" data-i18n="units_label">Localizaci√≥n</h4>
    <div class="config-row">
      <label for="language" data-i18n="language_label">Idioma:</label>
      <select id="language">
        <option value="es" selected>Espa√±ol</option>
        <option value="en">English</option>
      </select>
    </div>
    <div class="config-row">
      <div class="unit-pair">
        <label for="windUnits" data-i18n="wind_units_label">Unidades viento:</label>
        <select id="windUnits">
          <option value="kmh" selected>Km/h</option>
          <option value="ms">m/s</option>
          <option value="mph">Mph</option>
        </select>
      </div>
      <div class="unit-pair">
        <label for="tempUnits" data-i18n="temp_units_label">Unidades temperatura:</label>
        <select id="tempUnits">
          <option value="C" selected>¬∞C</option>
          <option value="F">¬∞F</option>
        </select>
      </div>
    </div>
   

    <div class="config-row">
      <div class="unit-pair">
        <label for="distanceUnits" data-i18n="distance_units_label">Unidades distancia:</label>
        <select id="distanceUnits">
          <option value="km" selected>Km</option>
          <option value="mi">Mi</option>
        </select>
      </div>
      <div class="unit-pair">
        <label for="precipUnits" data-i18n="precip_units_label">Unidades precipitaci√≥n:</label>
        <select id="precipUnits">
          <option value="mm" selected>Mm</option>
          <option value="in">In</option>
        </select>
      </div>
    </div>
  </div>
</aside>

<section id="debugSection" hidden>
  <div id="debugConsole" style="background:#222;color:#eee;font-family: monospace; font-size:12px; max-height:150px; overflow:auto; padding:10px;"></div>
</section>

<main>
  <div id="map" style="height:60vh;"></div>
  <div id="controlsPanel">
    <div class="params">
      <label for="datetimeRoute" data-i18n="route_datetime_label">Fecha y hora ruta:</label>
      <input type="datetime-local" id="datetimeRoute" step="900"/>

      <label for="cyclingSpeed" data-i18n="cycling_speed_label">Velocidad media (km/h):</label>
      <div class="speed-wrap">
        <input type="number" id="cyclingSpeed" value="20" min="5" max="60" />
        <select id="speedPresets" class="speed-presets" aria-label="Presets speed">
          <option value="" selected>‚Äî</option>
          <option value="5">5</option>
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="15">15</option>
          <option value="20">20</option>
        </select>
      </div>

      <label for="intervalSelect" data-i18n="interval_label">Intervalo (minutos):</label>
      <select id="intervalSelect">
        <option value="15" selected>15</option>
        <option value="30">30</option>
      </select>

      <!-- Provider selector moved here (to the right of Interval) -->
      <label for="apiSource" data-i18n="provider_label">Proveedor:</label>
      <select id="apiSource">
        <option value="meteoblue" selected>MeteoBlue</option>
        <option value="openmeteo">OpenMeteo</option>
        <option value="openweather">OpenWeather</option>
        <option value="aromehd">Arome‚ÄëHD</option>
        <!-- add compare option (no removals) -->
        <option value="compare">Comp.</option>
      </select>

      <!-- archivo GPX justo a continuaci√≥n del selector de intervalo -->
      <label class="file-btn small-file-btn" for="gpxFile" title="Upload file">üìÅ</label>
      <input type="file" id="gpxFile" accept=".gpx" />
    </div>

    <!-- Nombre de la ruta: nueva l√≠nea, justo debajo de los selectores y antes de la tabla -->
    <div id="rutaName" class="ruta-name" aria-live="polite"></div>

    <!-- NEW: forecast horizon/fallback notice -->
    <div id="horizonNotice" class="notice" hidden aria-live="polite"></div>

    <!-- CHANGED: add wrapper so overlays don't scroll -->
    <div class="wtc-wrap">
      <div id="weatherTableContainer">
        <table id="weatherTable"></table>
      </div>
    </div>
  </div>
</main>
<div id="loadingOverlay" data-i18n="loading_text" style=" position: fixed; z-index: 20000; inset: 0; background: rgba(255,255,255,0.7); display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; pointer-events: none; font-size: 1.5rem; color: #1e40af; font-weight: 700; user-select: none; ">
    Loading...
</div>

<!-- NEW: live viewport badge -->
<div id="vpBadge" aria-hidden="true"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.1.2/gpx.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-compass@1.5.6/dist/leaflet-compass.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script src="utils.js"></script>
<script src="ui.js"></script>
<script src="app.js"></script>
<script src="gpx-ingest.js"></script>
<!-- NEW: compare mode (loads after app to reuse hooks) -->
<script src="compare.js"></script>
<script>
// Affordance for horizontal scroll on the weather table (always visible when needed)
(function () {
  const c = document.getElementById('weatherTableContainer'); // inner scroller
  if (!c) return;
  const w = c.parentElement; // .wtc-wrap (overlay host)

  // Runtime safeguard for small screens (Edge/Safari/iOS quirks)
  try {
    const mq900 = window.matchMedia('(max-width: 900px)');
    const mq700 = window.matchMedia('(max-width: 700px)');
    const applyTA = () => {
      if (mq900.matches) {
        // <=900: enable inertial scrolling on iOS
        c.style.webkitOverflowScrolling = 'touch';
      }
      // <=700: force horizontal pan-only to avoid vertical gesture stealing
      if (mq700.matches) {
        c.style.touchAction = 'pan-x';
      } else if (mq900.matches) {
        c.style.touchAction = 'pan-x pan-y';
      } else {
        c.style.touchAction = 'auto';
      }
    };
    applyTA();
    (mq900.addEventListener ? mq900.addEventListener('change', applyTA) : mq900.addListener(applyTA));
    (mq700.addEventListener ? mq700.addEventListener('change', applyTA) : mq700.addListener(applyTA));
  } catch (_) {}

  function update() {
    const table = c.querySelector('#weatherTable');
    const innerWidth = table ? table.scrollWidth : c.scrollWidth;
    const canScroll = (innerWidth - c.clientWidth) > 2;
    w.classList.toggle('can-scroll', canScroll);
    if (!canScroll) {
      w.classList.remove('at-left','mid','at-right');
      return;
    }
    const atLeft = c.scrollLeft <= 0;
    const atRight = Math.ceil(c.scrollLeft + c.clientWidth) >= innerWidth;
    w.classList.toggle('at-left', atLeft);
    w.classList.toggle('at-right', atRight);
    w.classList.toggle('mid', !atLeft && !atRight);
  }

  c.addEventListener('scroll', update);

  // Wheel -> horizontal scroll helper (trackpads/mice)
  c.addEventListener('wheel', (ev) => {
    const table = c.querySelector('#weatherTable');
    const innerWidth = table ? table.scrollWidth : c.scrollWidth;
    const canScrollX = (innerWidth - c.clientWidth) > 2;
    if (!canScrollX) return;
    if (Math.abs(ev.deltaY) > Math.abs(ev.deltaX)) {
      c.scrollLeft += ev.deltaY;
      ev.preventDefault();
    }
  }, { passive: false });

  // drag-to-scroll helper (click-safe with threshold)
  let isDown = false, dragging = false, startX = 0, startLeft = 0;
  const DRAG_THRESH = 6;

  function begin(x) {
    isDown = true;
    dragging = false;
    startX = x;
    startLeft = c.scrollLeft;
  }
  function move(x, ev) {
    if (!isDown) return;
    const dx = x - startX;
    if (!dragging && Math.abs(dx) > DRAG_THRESH) {
      dragging = true;
      c.classList.add('dragging');
      document.body.classList.add('dragging');
    }
    if (dragging) {
      c.scrollLeft = startLeft - dx;
      if (ev) ev.preventDefault(); // only prevent default while dragging
    }
  }
  function end() {
    isDown = false;
    if (dragging) {
      dragging = false;
      c.classList.remove('dragging');
      document.body.classList.remove('dragging');
    }
  }

  // Prefer Pointer Events when available (covers mouse + touch uniformly)
  if (window.PointerEvent) {
    c.addEventListener('pointerdown', (e) => {
      if (e.button !== 0 && e.pointerType === 'mouse') return;
      begin(e.clientX);
      // do NOT preventDefault here to allow clicks if no drag
    }, { passive: true });
    c.addEventListener('pointermove', (e) => move(e.clientX, e), { passive: false });
    const endPtr = () => end();
    c.addEventListener('pointerup', endPtr, { passive: true });
    c.addEventListener('pointercancel', endPtr, { passive: true });
    c.addEventListener('pointerleave', (e) => { if (e.pointerType === 'mouse') end(); }, { passive: true });
  } else {
    // Mouse fallback
    c.addEventListener('mousedown', (e) => begin(e.clientX), { passive: true });
    window.addEventListener('mousemove', (e) => move(e.clientX, e), { passive: false });
    window.addEventListener('mouseup', end, { passive: true });
    // Touch fallback
    c.addEventListener('touchstart', (e) => {
      if (!e.touches?.length) return;
      begin(e.touches[0].clientX);
      // do NOT preventDefault here
    }, { passive: true });
    c.addEventListener('touchmove', (e) => {
      if (!e.touches?.length) return;
      move(e.touches[0].clientX, e);
    }, { passive: false });
    c.addEventListener('touchend', end, { passive: true });
    c.addEventListener('touchcancel', end, { passive: true });
  }

  // ResizeObserver: update on container resize (debounced)
  let resizeTimeout;
  const resizeObserver = new ResizeObserver(() => {
    if (resizeTimeout) clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(update, 150);
  });
  resizeObserver.observe(c);

  // MutationObserver: detect table changes (for GPX load + interval changes)
  const mutObserver = new MutationObserver(update);
  mutObserver.observe(document.getElementById('weatherTable'), { childList: true, subtree: true });

  // Initial load / timeout fallback
  setTimeout(update, 3000);
})();
</script>
<script>
// --- BEGIN: client-only GPX injection helpers (sessionStorage + direct) ---
// Provides a stable same-origin channel that survives reloads without relying on cross-site window.name.
// Scriptable (or any injector) can call window.cwInjectGPXFromText(text, name?) directly.
(function(){
  // Unified GPX loader facade. Uses your existing cwLoadGPXFromString(name?) when available; falls back to postMessage.
  window.cwInjectGPXFromText = function(gpxText, routeName){
    try {
      const name = routeName || 'Shared route';
      if (typeof window.cwLoadGPXFromString === 'function') {
        window.cwLoadGPXFromString(String(gpxText || ''), name);
        return true;
      }
      // Fallback: broadcast so late-loaded scripts can pick it up
      window.postMessage({ type: 'cw-gpx', name, gpx: String(gpxText || '') }, '*');
      return true;
    } catch(e){
      console.error('[cw] cwInjectGPXFromText error', e);
      return false;
    }
  };

  // Same-origin transient handoff: sessionStorage
  try {
    const KEY = 'cw_gpx_text';
    const KEY_NAME = 'cw_gpx_name';
    const ss = window.sessionStorage;
    const pending = ss ? ss.getItem(KEY) : null;
    if (pending) {
      const routeName = ss.getItem(KEY_NAME) || 'Shared route';
      // Clear before use to avoid loops
      ss.removeItem(KEY);
      ss.removeItem(KEY_NAME);
      // Feed it to the facade
      window.cwInjectGPXFromText(pending, routeName);
      console.log('[cw] loaded GPX from sessionStorage');
    }
  } catch(e){ console.warn('[cw] sessionStorage unavailable', e); }
})();
// --- END: client-only GPX injection helpers ---
    console.log('window.name on load:', window.name);
  console.log('window.name len:', (window.name||'').length);
(function(){
  console.log('>>> DIAGN√ìSTICO window.name');
  const w = String(window.name || '');
  console.log('window.name length:', w.length);
  console.log('window.name preview:', w.substring(0,400));
  if (!w) { console.warn('window.name vac√≠o ‚Üí el Shortcut no puso el payload'); return; }

  // ¬øParece XML ya?
  if (/^\s*(<\?xml|<gpx)/i.test(w)) {
    console.log('window.name parece XML directo. preview:', w.substring(0,1000));
    return;
  }

  // Intento: percent-decode -> restore '+' -> base64 -> utf-8 text
  try {
    const pct = decodeURIComponent(w);
    console.log('percent-decoded preview:', pct.substring(0,400));
    const b64 = String(pct).replace(/ /g, '+').replace(/-/g, '+').replace(/_/g, '/').replace(/\s+/g,'');
    let s = b64;
    while (s.length % 4) s += '=';
    const bin = atob(s);
    // convertir a string UTF-8 con TextDecoder
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i]=bin.charCodeAt(i);
    try {
      const txt = new TextDecoder('utf-8').decode(bytes);
      console.log('decoded text (utf-8) preview:', txt.substring(0,1500));
      console.log('decoded text length:', txt.length);
      return;
    } catch(e){
      console.warn('TextDecoder utf-8 fall√≥, mostrando raw atob preview');
      console.log(bin.substring(0,1500));
      return;
    }
  } catch (e) {
    console.error('Error al intentar decodificar window.name:', e);
  }

  console.warn('No se pudo reconocer/decodificar window.name. Revisar Shortcut (variable insertada y URL-encode).');
})();

  (  async function(){

  function toB64(s){
    return String(s || '').replace(/-/g, '+').replace(/_/g, '/').replace(/\s+/g,'');
  }

  function base64UrlToUint8Array(s){
    if (!s) return null;
    s = toB64(s);
    while (s.length % 4) s += '=';
    try {
      const bin = atob(s);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    } catch (e) {
      console.error('[cw] base64 decode failed', e);
      return null;
    }
  }

  function decodeHashGPX(enc){
    if (!enc) return null;
    let input = enc;
    try { input = decodeURIComponent(enc); } catch(_){}
    const bytes = base64UrlToUint8Array(input);
    if (!bytes) return null;
    console.log('[cw] decoded bytes length:', bytes.length);
    console.log('[cw] first 20 bytes hex:', bytes.slice(0,20).map(b => b.toString(16).padStart(2,'0')).join(' '));

    // gzip (0x1f 0x8b) or zlib (0x78) detection -> use pako if available
    if (bytes.length > 2 && bytes[0] === 0x1f && bytes[1] === 0x8b && window.pako?.ungzip){
      try { console.log('[cw] detected gzip, decompressing'); return window.pako.ungzip(bytes, { to: 'string' }); }
      catch(e){ console.warn('[cw] gzip decompress failed', e); }
    }
    if (bytes.length > 2 && bytes[0] === 0x78 && window.pako?.inflate){
      try { console.log('[cw] detected zlib/deflate, decompressing'); return window.pako.inflate(bytes, { to: 'string' }); }
      catch(e){ console.warn('[cw] zlib decompress failed', e); }
    }

    // Heuristic UTF-16 detection (lots of NULs in even/odd positions)
    try {
      let zerosEven = 0, zerosOdd = 0, limit = Math.min(bytes.length, 2000);
      for (let i = 0; i < limit; i++){
        if (bytes[i] === 0) { if ((i & 1) === 0) zerosEven++; else zerosOdd++; }
      }
      if (zerosEven > zerosOdd && zerosEven > limit * 0.2) {
        try { return new TextDecoder('utf-16le').decode(bytes); } catch(e){}
      } else if (zerosOdd > zerosEven && zerosOdd > limit * 0.2) {
        try { return new TextDecoder('utf-16be').decode(bytes); } catch(e){}
      }
    } catch(e){
      console.warn('[cw] utf16 detection failed', e);
    }

    try {
      return new TextDecoder('utf-8').decode(bytes);
    } catch (e) {
      console.error('[cw] TextDecoder utf-8 error', e);
      try { return atob(toB64(input)); } catch(_) { return null; }
    }
  }

  // Improved: remove namespaced attributes (xsi:...) before removing xmlns, then strip prefixes
  function stripNamespaces(gpxStr){
    if (!gpxStr) return gpxStr;
    let s = gpxStr;
    // remove attributes with prefixes like xsi:schemaLocation="..."
    s = s.replace(/\s+[a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+="[^"]*"/g, '');
    // remove xmlns declarations (default + prefixed)
    s = s.replace(/\s+xmlns(:\w+)?="[^"]*"/g, '');
    // collapse namespaced attributes (ns:attr="v" -> attr="v")
    s = s.replace(/\s+[a-zA-Z0-9_-]+:([a-zA-Z0-9_-]+)=/g, ' $1=');
    // remove namespace prefixes from element names: <ns:tag ...> -> <tag ...>, </ns:tag> -> </tag>
    s = s.replace(/<\s*\/\s*([a-zA-Z0-9_-]+):/g, '</$1');
    s = s.replace(/<\s*([a-zA-Z0-9_-]+):/g, '<$1');
    return s;
  }

  // Remove sections that contain many non-printable/binary chars (e.g. broken <author>)
  function stripBinarySections(gpxStr){
    if (!gpxStr) return gpxStr;
    return gpxStr.replace(/<([a-zA-Z0-9_-]+)(\b[^>]*)?>([\s\S]*?)<\/\1>/g, (full, tag, attrs, inner) => {
      const nonPrintable = (inner.match(/[^\u0009\u000A\u000D\u0020-\u007E\u00A0-\uD7FF\uE000-\uFFFD]/g) || []).length;
      if (nonPrintable > 10 || inner.indexOf('\u0000') !== -1) {
        console.log('[cw] removing binary content from tag', tag, 'nonPrintable=', nonPrintable);
        return `<${tag}${attrs||''}></${tag}>`;
      }
      return full;
    });
  }

  // Remove chars not allowed by XML 1.0
  function sanitizeXml(gpxStr){
    if (!gpxStr) return gpxStr;
    return gpxStr.replace(/[^\u0009\u000A\u000D\u0020-\uD7FF\uE000-\uFFFD]/g, '');
  }

  function debugDocCounts(gpxStr, note){
    try {
      const doc = new DOMParser().parseFromString(gpxStr || '', 'application/xml');
      const parserError = doc.getElementsByTagName('parsererror');
      if (parserError && parserError.length) {
        console.warn('[cw] DOMParser parsererror' + (note ? ' ('+note+')' : '') + ':', parserError[0].textContent.slice(0,400));
      }
      const trk = doc.getElementsByTagName('trk').length;
      const rte = doc.getElementsByTagName('rte').length;
      const wpt = doc.getElementsByTagName('wpt').length;
      console.log('[cw] parsed GPX counts' + (note ? ' ('+note+')' : ''), { trk, rte, wpt });
      console.log('[cw] gpx snippet' + (note ? ' ('+note+')' : '') + ':', (gpxStr||'').substring(0, 800).replace(/\s+/g,' '));
      return { doc, trk, rte, wpt, parserError: parserError && parserError.length ? parserError[0].textContent : null };
    } catch (e) {
      console.error('[cw] XML parse error', e);
      return null;
    }
  }

  // Try to ingest payload left in window.name (sender sets it and then navigates here)
  async function tryWindowNameIngest() {
    try {
      const w = (window.name || '').trim();
      if (!w) return false;
      if (w.length < 40) return false;
      console.log('[cw] window.name payload preview:', w.substring(0,200));
      const enc = String(w).replace(/ /g, '+');
      const gpxText = decodeHashGPX(enc);
      if (!gpxText) { console.warn('[cw] window.name decode failed'); return false; }
      const cleaned = stripNamespaces(gpxText);
      const binStripped = stripBinarySections(cleaned);
      const sanitized = sanitizeXml(binStripped);
      try { window.name = ''; } catch(e){}
      const name = 'Shared route';
      if (window.cwLoadGPXFromString && typeof window.cwLoadGPXFromString === 'function') {
        window.cwLoadGPXFromString(sanitized, name);
      } else {
        window.postMessage({ type: 'cw-gpx', name, gpx: sanitized }, '*');
      }
      console.log('[cw] loaded GPX from window.name');
      return true;
    } catch (e) {
      console.error('[cw] tryWindowNameIngest error', e);
      return false;
    }
  }

  async function waitForMap(timeoutMs = 5000) {
    if (window.map && typeof window.map.addLayer === 'function') return window.map;
    return new Promise((resolve, reject) => {
      const start = Date.now();
      const iv = setInterval(() => {
        if (window.map && typeof window.map.addLayer === 'function') {
          clearInterval(iv);
          resolve(window.map);
        } else if (Date.now() - start > timeoutMs) {
          clearInterval(iv);
          reject(new Error('map not ready'));
        }
      }, 100);
    });
  }

  async function processHashGPX(){
    try {
      const hash = (location.hash || '').replace(/^#/, '');
      if (!hash) return;
      const params = new URLSearchParams(hash);
      const rawEnc = params.get('gpx');
      if (!rawEnc) return;

      // Restore '+' that URL parsers may have turned into spaces
      const encRestoredPlus = String(rawEnc).replace(/ /g, '+');

      // small preview logging
      try {
        const PREVIEW_LEN = 600;
        const TAIL_LEN = 120;
        const raw = String(rawEnc);
        const head = raw.substring(0, PREVIEW_LEN);
        const tail = raw.length > TAIL_LEN ? '...' + raw.slice(-TAIL_LEN) : '';
        let decodedURIComponentPreview = head;
        try { decodedURIComponentPreview = decodeURIComponent(String(rawEnc)).substring(0, PREVIEW_LEN); } catch(_){}
        console.log('[cw] raw gpx param (b64) head:', head);
        if (tail) console.log('[cw] raw gpx param (b64) tail:', tail);
        console.log('[cw] decodeURIComponent head preview:', decodedURIComponentPreview);
        console.log('[cw] restored "+" preview head (spaces->+):', String(encRestoredPlus).substring(0, PREVIEW_LEN));
        try {
          const previewBytes = base64UrlToUint8Array(encRestoredPlus);
          if (previewBytes && previewBytes.length) {
            const nz = previewBytes.slice(0, 64);
            console.log('[cw] decoded bytes preview (hex):', nz.map(b=>b.toString(16).padStart(2,'0')).join(' '), '... (len=' + previewBytes.length + ')');
          }
        } catch (e) {
          console.warn('[cw] could not convert preview to bytes', e);
        }
      } catch (e) { /* ignore preview errors */ }

      const name = params.get('name') ? decodeURIComponent(params.get('name')) : 'Shared route';
      const gpx = decodeHashGPX(encRestoredPlus);
      if (!gpx) {
        console.error('[cw] could not decode GPX from hash');
        return;
      }

      debugDocCounts(gpx, 'original');

      const cleaned = stripNamespaces(gpx);
      debugDocCounts(cleaned, 'cleaned');

      const binStripped = stripBinarySections(cleaned);
      debugDocCounts(binStripped, 'binary-stripped');

      const sanitized = sanitizeXml(binStripped);
      debugDocCounts(sanitized, 'sanitized');

      const payload = sanitized;

      // wait for map to be ready to avoid addLayer errors
      try {
        await waitForMap(5000);
      } catch (err) {
        console.warn('[cw] map not ready after timeout, will try to load anyway', err);
      }

      if (window.cwLoadGPXFromString && typeof window.cwLoadGPXFromString === 'function') {
        try {
          console.log('[cw] calling cwLoadGPXFromString(name,len) with sanitized GPX', name, payload.length);
          window.cwLoadGPXFromString(payload, name);
        } catch (err) {
          console.error('[cw] cwLoadGPXFromString threw', err);
          window.postMessage({ type: 'cw-gpx', name, gpx: payload }, '*');
        }
      } else {
        console.log('[cw] posting cw-gpx via postMessage (fallback, sanitized)');
        window.postMessage({ type: 'cw-gpx', name, gpx: payload }, '*');
      }

      try { history.replaceState(null, '', location.pathname + location.search); } catch(e){}
    } catch (e) {
      console.error('[cw] processHashGPX error', e);
    }
  }

  // Try window.name first (awaitable because IIFE is async)
  try { await tryWindowNameIngest(); } catch(_) {}

  // Then process any #gpx fragment
  try { await processHashGPX(); } catch(_) {}

  window.addEventListener('hashchange', processHashGPX, false);
  window.__cw_processHashGPX = processHashGPX;

})();

// Allow external injector to stage large payload via sessionStorage and reload same-origin safely
window.__cw_stageAndReload = function(gpxText, routeName){
  try {
    sessionStorage.setItem('cw_gpx_text', String(gpxText||''));
    if (routeName) sessionStorage.setItem('cw_gpx_name', String(routeName));
    location.reload();
    return true;
  } catch(e){ console.error('stageAndReload failed', e); return false; }
};
</script>
</html>